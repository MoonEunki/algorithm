정렬하는 방법에는 여러가지가 있다. 적절하지못한 정렬 알고리즘을 사용하면 정렬에 오랜시간이 걸릴것이다.

# 선택정렬

가장 작은 데이터를 `선택` 해서 맨앞데이터와 바꾸고, 그다음 작은 데이터를 선택해서 두번째데이터와 바꾸고.. 이런식으로 정렬하는 알고리즘이다 그래서 선택정렬이라고 부름

| 데이터의 개수(N) | 선택정렬 | 퀵 정렬   | 파이썬 기본 정렬 라이브러리 |
| ---------------- | -------- | --------- | --------------------------- |
| N=100            | 0.0123초 | 0.00156초 | 0.00000753초                |
| N=1000           | 0.356    | 0.00343초 | 0.0000365초                 |
| N=10000          | 15.475초 | 0.0312초  | 0.000248초                  |

선택정렬은 _O(N^2)_ 이라 데이터가 많을수록 엄청느려짐

# 삽입 정렬

적절한위치에 데이터를 `삽입`하는 방식이라 삽입정렬이라고 부른다. 데이터가 이미 거의 정렬되어있다면 매우빠르게 동작하는 특징이있다, 기본적으로 _O(N^2)_ 인데, 최선의 경우(정렬된경우) _O(N)_ 시간복잡도를 가진다.

# 퀵 정렬

이름부터 빠른 퀵정렬의 시간복잡도는 _O(NlogN)_ 이다. 하지만 최악의 경우 _O(N^2)_ 이다. 데이터가 무작위로 입력되는경우 퀵정렬은 빠르게 동작할 확률이 높지만, 이미 정렬된 데이터를 입력하는경우는 매우 느리게 동작한다. 삽입정렬은 정렬된 데이터일때 빠르게 동작하는데 퀵정렬은 반대이다.

# 계수 정렬

특정한 조건이 부합할때만 사용할수있지만, 매우빠른 정렬 알고리즘이다.

모든 데이터가 양의정수일때 데이터의 개수가 N개, 최댓값이 K일때 최악의경우에도 _O(N+K)_ 를 보장한다.

계수정렬은 이번에 처음알았는데, 굉장히 신기한 방식이다. 만약 가장 작은데이터가 0이고 가장큰 데이터가 10이면, 11칸 배열을 선언한다. 그다음 모든 데이터를 순회하면서 데이터에 해당하는 인덱스를 +1 해준다 예를들어 8이면 8번째 인덱스를 +1해주는방식.. 모든 데이터 순회가 끝난뒤에는 이 배열을 순회하면서 인덱스에 할당된 숫자만큼 인덱스를 출력하면된다.

만약 0,2,5,8,1,2,4,6 이렇게 데이터가 있을때 가장 작은 데이터가 0이고 가장 큰 데이터가 8이니까 9칸짜리 배열을 선언한다.

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |

데이터를 순회하면서 각 데이터에 해당하는 인덱스를 +1 해준다.

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 1   | 2   | 0   | 1   | 1   | 1   | 0   | 1   |

배열에 이렇게 값이 들어갈것이고

이 배열을 순회하면서 인덱스에 해당하는 값만큼 출력하면된다

0은 1개 1은 1개 2는 2개 3은없고 4는 1개 5는 1개 6은 1개 7은 없고 8은 1개

0 1 2 2 4 5 6 8

계수정렬은 데이터의 크기가 한정되어있고 많이 중복될수록 유리하다

# 위에서 아래로

```javascript
function solution(arr) {
  return arr.sort((a, b) => a - b).reverse();
}

console.log(solution([1, 3, 1, 4, 7, 10]));
```

단순한 내림차순 정렬문제다

# 성적이 낮은 순서로 학생 출력하기

```javascript
function solution(arr) {
  return arr.sort((a, b) => a[1] - b[1]).map((v) => v[0]);
}
console.log(
  solution([
    ['홍길동', 95],
    ['이순신', 77],
    ['홍순동', 10],
    ['순신이', 57],
    ['홍신동', 15],
    ['엄순길', 67],
  ])
);
```

sort함수로 성적낮은순으로 정렬한뒤 map으로 이름만뽑아서 배열로 반환했다. 이번문제는 학생수가 1~10만까지였기때문에, _O(N)_ 이나 _O(NlogN)_ 을 보장하는 정렬알고리즘을 사용했어야한다. 10만개 랜덤데이터를 넣어봤는데 100ms도 안나와서 신기했음.

# 두 배열의 원소 교체

```javascript
function solution(k, arr1, arr2) {
  let sum = 0;

  arr1.sort((a, b) => a - b);
  arr2.sort((a, b) => a - b).reverse();

  for (let i = 0; i < arr1.length; i++) {
    if (i < k) sum += arr2[i];
    else sum += arr1[i];
  }

  return sum;
}
console.log(solution(3, [1, 2, 5, 4, 3], [5, 5, 6, 6, 5]));
```

N은 1~10만, K는 0~N 범위를 가진다
A배열과 B배열에있는 element를 K번 바꿔서 A배열 요소의 총 합이 가장 큰값을 구해야된다.

만약 K가 3일경우.

A배열을 오름차순으로 정렬하고 [ 1, 2, 3, 4, 5 ]

B배열을 내림차순으로 정렬한다음 [ 6, 6, 5, 5, 5 ]

B배열에서 0,1,2 인덱스를 sum에 더하고 3,4 인덱스를 A배열에서 더하게 했다

6,6,5 는 B배열 그리고 4,5 는 A배열에서 뽑아서 더하니까 답은 26
